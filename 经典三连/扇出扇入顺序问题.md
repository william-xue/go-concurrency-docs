# 扇出扇入顺序问题

## 核心问题：能否交换扇出和扇入的顺序？

**答案：不能**，会导致死锁。

---

## 一、错误示范（死锁）

```go
// ❌ 先扇入再扇出 = 死锁
maxLoss := 0.0
for i := 1; i <= totalSnapshots; i++ {
    currentLoss := <-results  // 💀 死锁：channel 是空的，没有生产者
    if currentLoss > maxLoss {
        maxLoss = currentLoss
    }
}

// 永远执行不到这里
for i := 1; i <= totalSnapshots; i++ {
    go calcPowerFlow(i, results)
}
```

### 死锁原因

1. 程序走到第一个 `<-results`
2. main goroutine **阻塞等待** channel 有数据
3. 但此时还没有任何 worker goroutine 在运行（扇出还没执行）
4. **没人发送数据** → main 永远等待 → **死锁**

---

## 二、正确写法

```go
// ✅ 必须先扇出（启动生产者）→ 再扇入（消费数据）
for i := 1; i <= totalSnapshots; i++ {
    go calcPowerFlow(i, results)  // 96个工人开始干活
}

maxLoss := 0.0
for i := 1; i <= totalSnapshots; i++ {
    currentLoss := <-results  // 阻塞等待每个结果
    if currentLoss > maxLoss {
        maxLoss = currentLoss
    }
}
```

### 类比

你不能在工厂工人还没上班时，就站在流水线尽头等产品——会一直等下去。  
必须先让工人开工（扇出），你再去收货（扇入）。

---

## 三、Channel 接收语法：`<-`

```go
currentLoss := <-results
//   ↑          ↑    ↑
//   |          |    |
// 新变量     接收   channel名
//         操作符
```

### 箭头方向 = 数据流向

| 操作 | 语法 | 含义 |
|------|------|------|
| **发送** | `chan <- data` | 数据流进 channel ➡️ |
| **接收** | `data := <-chan` | 数据流出 channel ⬅️ |

### 执行行为

```go
currentLoss := <-results  
// 1. 程序走到这里会【阻塞等待】
// 2. 直到有某个 goroutine 往 results 里发送数据
// 3. 接收到数据后，赋值给 currentLoss
// 4. 继续执行下一行代码
```

---

## 四、Buffered vs Unbuffered Channel

### 当前代码：带缓冲（Buffered）

```go
results := make(chan float64, 96)  // 容量96
```

**行为**：
- 工人算完直接放传送带上（**不阻塞**）
- 传送带可以堆积 96 个结果
- 老板慢慢收货

```go
// 工人侧（不阻塞，直接放货就走）
resultChan <- loss  

// 老板侧（96个结果可能都已经在传送带上了）
currentLoss := <-results
```

### 如果改成无缓冲（Unbuffered）

```go
results := make(chan float64)  // 容量0
```

**行为**：
- 工人算完后尝试发送 → **阻塞等待**有人接收
- 当 main 执行 `<-results` 时，才有一个工人被唤醒发送数据
- **握手式同步**：必须一收一发同时发生

```go
// 工人侧（会阻塞，直到有人接收）
resultChan <- loss  // 等待...

// 老板侧（每接收一次，唤醒一个阻塞的工人）
currentLoss := <-results  // 握手成功
```

**无缓冲也能正常工作**，但带缓冲效率更高（工人不用等待接收者）。

---

## 五、必须先扇出的前提

**带缓冲 channel（当前代码）**：
- ✅ 先扇出 → 再扇入（推荐，工人不阻塞）
- ✅ 无缓冲时也必须先扇出（工人会阻塞，但不会死锁）

**关键**：
- 生产者（goroutine）必须先启动
- 消费者（main）再开始接收
- 否则没人生产 → 消费者永远等待 → 死锁

---

## 六、实战建议

1. **默认使用带缓冲 channel**：容量 = 预期结果数（避免不必要的阻塞）
2. **扇出在前，扇入在后**：这是 Go 并发的标准模式
3. **测试死锁**：试着交换顺序运行，Go 会报 `fatal error: all goroutines are asleep - deadlock!`

---

## 相关代码

参见：`经典三连/基础版:v1_basic.go (无锁高并发骨架).go`
